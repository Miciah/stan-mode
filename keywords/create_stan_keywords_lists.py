import json
import re
import sys

_TEMPLATE = """;;; stan-keywords-lists.el -- file auto generated by keywords/create_stan_keywords_list.py

(defvar stan-types-list
  {types}
  "List of Stan data types")

(defvar stan-blocks-list
  {blocks}
  "List of Stan block names")

(defvar stan-bounds-list
  {bounds}
  "List of keywords in Stan bounds statements")

(defvar stan-keywords-list
  {keywords}
  "List of Stan keywords")

(defvar stan-functions-list
  {functions}
  "List of Stan functions")

(defvar stan-distribution-list
  {distributions}
  "List of Stan distributions")

(defvar stan-reserved-list
  {reserved}
  "List of Stan reserved keywords")

(provide 'stan-keywords-lists)
;;; stan-keywords-lists.el ends here
"""

DISTR_PARTS = ('Continuous Distributions', 'Discrete Distributions')

def read_json(filename):
    with open(filename, "r") as f:
        data = json.load(f)

    keywords = sorted(data['keywords'] + data['pseudo_keywords'])
    reserved = sorted([x for x in data['reserved'] + data['cpp_reserved']
                       if x not in keywords])
    types = sorted(data['types'])
    blocks = sorted(data['blocks'])
    bounds = sorted(data['bounds'])

    functions = set()
    distributions = set()

    re_op = re.compile("^operator")
    re_pdf = re.compile("_log$")
    re_cdf = re.compile("_cdf$")
    re_cdf_log = re.compile("_cdf_log$")
    re_ccdf_log = re.compile("_ccdf_log$")

    for fun_name in data['functions']:
        if re_op.match(fun_name):
            continue
        if (not re_ccdf_log.search(fun_name)
            and not re_cdf_log.search(fun_name)
            and re_pdf.search(fun_name)):
            for sig, val in data['functions'][fun_name].items():
                if val['location'][0] in DISTR_PARTS:
                    distributions.add(re.sub("_log$", "", fun_name))
        functions.add(fun_name)

    return {
        'blocks': blocks,
        'bounds': bounds,
        'distributions': list(distributions),
        'functions': list(functions),
        'keywords': keywords,
        'reserved': reserved,
        'types': types,
    }

def sexp(x):
    return "'(" + ' '.join('"%s"' % atom for atom in x) + ")"

def create_code(data):
    print(_TEMPLATE.format(**data))

if __name__ == '__main__':
    data = read_json(sys.argv[1])
    create_code(dict([(k, sexp(sorted(v))) for k, v in data.items()]))

